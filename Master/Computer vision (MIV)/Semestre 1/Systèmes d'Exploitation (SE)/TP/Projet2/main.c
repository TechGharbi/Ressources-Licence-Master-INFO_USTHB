#include "commun.h"
#define FTOK_PROJ_ID 'T'

// Global variables for cleanup
int qcr_global, qncr_global, qimp_global, semid_global, shmid_global;
const char *fifo;

void err_exit(const char *s){
    perror(s);
    exit(EXIT_FAILURE);
}

void cleanup(int sig) {
    printf("\nðŸ§¹ Nettoyage des IPC...\n");
    
    // Clean message queues
    msgctl(qcr_global, IPC_RMID, NULL);
    msgctl(qncr_global, IPC_RMID, NULL);
    msgctl(qimp_global, IPC_RMID, NULL);
    
    // Clean semaphores
    semctl(semid_global, 0, IPC_RMID);
    
    // Clean shared memory
    shmctl(shmid_global, IPC_RMID, NULL);
    
    // Clean FIFO tube
    unlink(fifo);
    
    // Clean key file
    unlink(FTOK_PATH);
    
    printf("ðŸ§¹ Tous les IPC ont ete supprimes\n");
    exit(0);
}

int main(){
    // create key file for ftok
    FILE *f = fopen(FTOK_PATH,"w");
    if(!f) err_exit("fopen ftok");
    fprintf(f,"tp2\n");
    fclose(f);

    key_t key = ftok(FTOK_PATH, FTOK_PROJ_ID);
    if(key == -1) err_exit("ftok");

    // create message queues keys derived from key
    key_t key_qcr = ftok(FTOK_PATH, 'A');
    key_t key_qncr = ftok(FTOK_PATH, 'B');
    key_t key_qimp = ftok(FTOK_PATH, 'C');
    key_t key_sem = ftok(FTOK_PATH, 'D');
    key_t key_shm = ftok(FTOK_PATH, 'E');

    // Use global variables directly (no local shadowing)
    qcr_global = msgget(key_qcr, IPC_CREAT | 0666);
    qncr_global = msgget(key_qncr, IPC_CREAT | 0666);
    qimp_global = msgget(key_qimp, IPC_CREAT | 0666);
    
    if(qcr_global == -1 || qncr_global == -1 || qimp_global == -1) err_exit("msgget");

    // semaphores: we will create 2 semaphores (empty, mutex)
    semid_global = semget(key_sem, 2, IPC_CREAT | 0666);
    if(semid_global == -1) err_exit("semget");

    // initialize semaphores: EMPTY_SEM = N, MUTEX_SEM = 1
    unsigned short initvals[2] = {N, 1};
    if(semctl(semid_global, 0, SETALL, initvals) == -1) err_exit("semctl SETALL");

    // shared memory for tampon 
    shmid_global = shmget(key_shm, sizeof(struct Tampon), IPC_CREAT | 0666);
    if(shmid_global == -1) err_exit("shmget");

    // initialize shared memory
    struct Tampon *tampon_ptr = (struct Tampon*)shmat(shmid_global, NULL, 0);
    if(tampon_ptr == (void*)-1) err_exit("shmat init");
    tampon_ptr->head = 0;
    tampon_ptr->tail = 0;  
    tampon_ptr->count = 0;
    shmdt(tampon_ptr);

    // create FIFO tube
    fifo = "/tmp/tube_tp2";
    unlink(fifo);
    if(mkfifo(fifo, 0666) == -1) {
        if(errno != EEXIST) err_exit("mkfifo");
    }

    // Register signal handler for cleanup on SIGINT (Ctrl+C)
    signal(SIGINT, cleanup);

    printf("HÃ”PITAL OUVERT - Chirurgien prÃªt (priorite aux critiques)\n");

    // fork/exec patients, chirurgien, donneur
    pid_t pid;

    pid = fork();
    if(pid == 0){
        execl("./malade_critique", "./malade_critique", NULL);
        err_exit("execl malade_critique");
    }

    pid = fork();
    if(pid == 0){
        execl("./malade_non_critique", "./malade_non_critique", NULL);
        err_exit("execl malade_non_critique");
    }

    // Chirurgien process
    pid = fork();
    if(pid == 0){
        execl("./chirurgien", "./chirurgien", NULL);
        err_exit("execl chirurgien");
    }

    // Donneur process
    pid = fork();
    if(pid == 0){
        execl("./donneur", "./donneur", NULL);
        err_exit("execl donneur");
    }

    // parent waits for 4 children
    for(int i=0; i<4; i++){
        wait(NULL);
    }

    // cleanup on normal exit
    cleanup(0);

    return 0;
}