#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Structure pour stocker les informations d'une tâche
typedef struct {
    int numero;
    char operation[256];
} Tache;

Tache taches[100];
int compteur_taches = 0;

// Fonction pour trouver l'opérateur central
int trouver_operateur_central(char *expression) {
    int parenthese_count = 0;
    int longueur = strlen(expression);
    
    // Ignorer les parenthèses externes si elles existent
    int debut = 0;
    int fin = longueur - 1;

    
    if (expression[debut] == '(' && expression[fin] == ')') {
        debut++;
        fin--;
    }
    
    for (int i = debut; i <= fin; i++) {
        if (expression[i] == '(') {
            parenthese_count++;
        } else if (expression[i] == ')') {
            parenthese_count--;
        } else if (parenthese_count == 0 && 
                  (expression[i] == '+' || expression[i] == '-' || 
                   expression[i] == '*' || expression[i] == '/')) {
            return i;
        }
    }
    
    return -1; // Aucun opérateur trouvé
}

// Fonction pour extraire la sous-expression gauche
char* sous_expression_gauche(char *expression, int position_operateur) {
    char *sous_expr = malloc(100);
    int i;
    for (i = 1; i < position_operateur; i++) {
        sous_expr[i - 1] = expression[i];
    }
    sous_expr[i - 1] = '\0';  
    sous_expr[position_operateur - 1] = '\0';
    return sous_expr;
}

// Fonction pour extraire la sous-expression droite
char* sous_expression_droite(char *expression, int position_operateur) {
    char *sous_expr = malloc(100);
    int i, j = 0;
    for (i = position_operateur + 1; expression[i] != '\0'; i++) {
        sous_expr[j++] = expression[i];
    }
    sous_expr[j] = '\0';  

    sous_expr[strlen(sous_expr) - 1] = '\0'; // Enlever la parenthèse fermante
    return sous_expr;
}

// Fonction pour calculer le nombre d'opérations dans une sous-expression
int calculer_nombre_operations(char *expression) {
    int count = 0;
    int longueur = strlen(expression);
    
    for (int i = 0; i < longueur; i++) {
        if (expression[i] == '+' || expression[i] == '-' || 
            expression[i] == '*' || expression[i] == '/') {
            count++;
        }
    }
    
    return count;
}

// Fonction pour vérifier si c'est une expression simple (variable/constante)
int est_expression_simple(char *expression) {
    int longueur = strlen(expression);
    
    // Si la longueur est 1 et c'est un caractère alphabétique ou numérique
    if (longueur == 1 && (isalpha(expression[0]) || isdigit(expression[0]))) {
        return 1;
    }
    
    // Vérifier s'il n'y a pas d'opérateurs (hors parenthèses)
    for (int i = 0; i < longueur; i++) {
        if (expression[i] == '+' || expression[i] == '-' || 
            expression[i] == '*' || expression[i] == '/') {
            return 0;
        }
    }
    
    return 1;
}

// Fonction pour générer le contenu d'une tâche
void generer_contenu_tache(char *expression, int numero_tache, int x, char operateur) {
    char gauche[50], droite[50];
    
    // Extraire les sous-expressions
    int pos_op = trouver_operateur_central(expression);
    
    // Générer les noms des variables temporaires pour la partie gauche
    if (x > 0) {
        sprintf(gauche, "M%d", numero_tache + 1);
    } else {
        // Extraire l'opérande gauche directement
        if (pos_op != -1) {
            char *sous_gauche = sous_expression_gauche(expression, pos_op);
            int i = 0;
            while (sous_gauche[i] != '\0') {
                gauche[i] = sous_gauche[i];
                i++;
            }
            gauche[i] = '\0';  // Fin de chaîne

            free(sous_gauche);
        }
    }
    
    int nb_operations_droite = calculer_nombre_operations(expression) - x - 1;
    if (nb_operations_droite > 0) {
        sprintf(droite, "M%d", numero_tache + x + 1);
    } else {
        // Extraire l'opérande droite directement
        if (pos_op != -1) {
            char *sous_droite = sous_expression_droite(expression, pos_op);
            int i = 0;
            while (sous_droite[i] != '\0') {
                droite[i] = sous_droite[i];
                i++;
            }
            droite[i] = '\0';  // Fin de chaîne

            free(sous_droite);
        }
    }
    
    // Stocker la tâche
    taches[compteur_taches].numero = numero_tache;
    snprintf(taches[compteur_taches].operation,
         sizeof(taches[compteur_taches].operation),
         "T%d : M%d := %s %c %s",
         numero_tache, numero_tache, gauche, operateur, droite);

    compteur_taches++;
}

// Fonction pour afficher la relation père-fils avec le contenu de la tâche
void afficher_relation_pere_fils(int numero_tache, int tache_parente) {
    if (tache_parente == -1) {
        printf("Processus T%d est le pere : ", numero_tache);
    } else {
        printf("Processus T%d fils de T%d : ", numero_tache, tache_parente);
    }
    
    // Afficher l'opération de la tâche courante
    for (int i = 0; i < compteur_taches; i++) {
        if (taches[i].numero == numero_tache) {
            printf("%s\n", taches[i].operation);
            break;
        }
    }
}

// Fonction récursive principale
void generer(char *expression, int numero_tache, int tache_parente) {
    int position_operateur = trouver_operateur_central(expression);
    
    if (position_operateur == -1) {
        return;
    }
    
    char operateur = expression[position_operateur];
    
    // Extraire les sous-expressions
    char *sous_expr_gauche = sous_expression_gauche(expression, position_operateur);
    char *sous_expr_droite = sous_expression_droite(expression, position_operateur);
    
    // Calculer le nombre d'opérations dans la sous-expression gauche
    int x = calculer_nombre_operations(sous_expr_gauche);
    
    // Générer le contenu de la tâche actuelle AVANT d'afficher
    generer_contenu_tache(expression, numero_tache, x, operateur);
    
    // Maintenant afficher la relation père-fils avec le contenu
    afficher_relation_pere_fils(numero_tache, tache_parente);
    
    // Afficher la relation de précédence si nécessaire
    if (tache_parente != -1) {
        printf("T%d < T%d\n", numero_tache, tache_parente);
    }
    
    // Appel récursif pour la sous-expression gauche si nécessaire
    if (!est_expression_simple(sous_expr_gauche)) {
        generer(sous_expr_gauche, numero_tache + 1, numero_tache);
    }
    
    // Appel récursif pour la sous-expression droite si nécessaire
    if (!est_expression_simple(sous_expr_droite)) {
        generer(sous_expr_droite, numero_tache + x + 1, numero_tache);
    }
    
    free(sous_expr_gauche);
    free(sous_expr_droite);
}

// Fonction principale
int main() {
    char expression[100];
    
    printf("Donner L'expression:\n");
    fgets(expression, sizeof(expression), stdin);
    
    // Supprimer le saut de ligne
for (int i = 0; expression[i] != '\0'; i++) {
    if (expression[i] == '\n') {
        expression[i] = '\0';
        break;
    }
}    
    printf("\n");
    
    // Appel initial de la fonction générer
    generer(expression, 1, -1);
    
    return 0;
}

//(((A+B)*C)-(((D-(F/G))*(H+(K*L)))/((M-N)*O)))

