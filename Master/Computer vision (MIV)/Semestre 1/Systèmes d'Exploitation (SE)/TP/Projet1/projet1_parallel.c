#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/wait.h>

// Structure pour stocker les informations d'une tache
typedef struct {
    int numero;
    char operation[256];
} Tache;

Tache taches[100];
int compteur_taches = 0;

// ------------------- Fonctions utilitaires -------------------

int trouver_operateur_central(char *expression) {
    int parenthese_count = 0;
    int longueur = strlen(expression);
    int debut = 0;
    int fin = longueur - 1;

    if (expression[debut] == '(' && expression[fin] == ')') {
        debut++;
        fin--;
    }

    for (int i = debut; i <= fin; i++) {
        if (expression[i] == '(') parenthese_count++;
        else if (expression[i] == ')') parenthese_count--;
        else if (parenthese_count == 0 &&
                 (expression[i] == '+' || expression[i] == '-' ||
                  expression[i] == '*' || expression[i] == '/')) {
            return i;
        }
    }
    return -1;
}

char* sous_expression_gauche(char *expression, int position_operateur) {
    char *sous_expr = malloc(100);
    int i;
    for (i = 1; i < position_operateur; i++) {
        sous_expr[i - 1] = expression[i];
    }
    sous_expr[i - 1] = '\0';
    return sous_expr;
}

char* sous_expression_droite(char *expression, int position_operateur) {
    char *sous_expr = malloc(100);
    int i, j = 0;
    for (i = position_operateur + 1; expression[i] != '\0'; i++) {
        sous_expr[j++] = expression[i];
    }
    sous_expr[j] = '\0';
    if (sous_expr[j - 1] == ')') sous_expr[j - 1] = '\0';
    return sous_expr;
}

int calculer_nombre_operations(char *expression) {
    int count = 0;
    for (int i = 0; expression[i] != '\0'; i++) {
        if (expression[i] == '+' || expression[i] == '-' ||
            expression[i] == '*' || expression[i] == '/')
            count++;
    }
    return count;
}

int est_expression_simple(char *expression) {
    int longueur = strlen(expression);
    if (longueur == 1 && (isalpha(expression[0]) || isdigit(expression[0])))
        return 1;
    for (int i = 0; i < longueur; i++) {
        if (expression[i] == '+' || expression[i] == '-' ||
            expression[i] == '*' || expression[i] == '/')
            return 0;
    }
    return 1;
}

// ------------------- Fonctions principales -------------------

void generer_contenu_tache(char *expression, int numero_tache, int x, char operateur) {
    char gauche[50], droite[50];
    int pos_op = trouver_operateur_central(expression);

    if (x > 0) sprintf(gauche, "M%d", numero_tache + 1);
    else {
        char *sous_gauche = sous_expression_gauche(expression, pos_op);
        int i = 0; while (sous_gauche[i] != '\0') { gauche[i] = sous_gauche[i]; i++; }
        gauche[i] = '\0';
        free(sous_gauche);
    }

    int nb_operations_droite = calculer_nombre_operations(expression) - x - 1;
    if (nb_operations_droite > 0) sprintf(droite, "M%d", numero_tache + x + 1);
    else {
        char *sous_droite = sous_expression_droite(expression, pos_op);
        int i = 0; while (sous_droite[i] != '\0') { droite[i] = sous_droite[i]; i++; }
        droite[i] = '\0';
        free(sous_droite);
    }

    taches[compteur_taches].numero = numero_tache;
    snprintf(taches[compteur_taches].operation,
             sizeof(taches[compteur_taches].operation),
             "T%d : M%d := %s %c %s",
             numero_tache, numero_tache, gauche, operateur, droite);
    compteur_taches++;
}

void afficher_relation_pere_fils(int numero_tache, int tache_parente) {
    if (tache_parente == -1)
        printf("Processus T%d est le pere : ", numero_tache);
    else
        printf("Processus T%d fils de T%d : ", numero_tache, tache_parente);

    for (int i = 0; i < compteur_taches; i++) {
        if (taches[i].numero == numero_tache) {
            printf("%s\n", taches[i].operation);
            break;
        }
    }
}

// ------------------- Fonction récursive parallèle -------------------

void generer(char *expression, int numero_tache, int tache_parente) {
    int position_operateur = trouver_operateur_central(expression);
    if (position_operateur == -1) return;

    char operateur = expression[position_operateur];
    char *sous_expr_gauche = sous_expression_gauche(expression, position_operateur);
    char *sous_expr_droite = sous_expression_droite(expression, position_operateur);
    int x = calculer_nombre_operations(sous_expr_gauche);

    generer_contenu_tache(expression, numero_tache, x, operateur);
    afficher_relation_pere_fils(numero_tache, tache_parente);

    if (tache_parente != -1)
        printf("T%d < T%d\n", numero_tache, tache_parente);

    pid_t pid_gauche = -1, pid_droite = -1;

    // ---- Creation du processus fils pour la sous-expression gauche ----
    if (!est_expression_simple(sous_expr_gauche)) {
        pid_gauche = fork();
        if (pid_gauche == 0) {  // Fils gauche
            generer(sous_expr_gauche, numero_tache + 1, numero_tache);
            free(sous_expr_gauche);
            free(sous_expr_droite);
            exit(0);
        }
    }

    // ---- Création du processus fils pour la sous-expression droite ----
    if (!est_expression_simple(sous_expr_droite)) {
        pid_droite = fork();
        if (pid_droite == 0) {  // Fils droit
            generer(sous_expr_droite, numero_tache + x + 1, numero_tache);
            free(sous_expr_gauche);
            free(sous_expr_droite);
            exit(0);
        }
    }

    // ---- Attente des fils ----
    if (pid_gauche > 0) waitpid(pid_gauche, NULL, 0);
    if (pid_droite > 0) waitpid(pid_droite, NULL, 0);

    free(sous_expr_gauche);
    free(sous_expr_droite);
}

// ------------------- Main -------------------

int main() {
    char expression[200];
    printf("Donner L'expression:\n");
    fgets(expression, sizeof(expression), stdin);
    expression[strcspn(expression, "\n")] = 0;

    printf("\n========== Génération parallèle ==========\n\n");
    generer(expression, 1, -1);
    return 0;
}

//(((A+B)*C)-(((D-(F/G))*(H+(K*L)))/((M-N)*O)))