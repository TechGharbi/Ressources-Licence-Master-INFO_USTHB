#include "commun.h"

typedef struct {
    int valide;
    int num_organe;
} Request;

void enregistrer(Request *Tcr, Request *Tncr, struct imp_msg mess2) {
    if (mess2.type_malade == 1) {
        Tcr[mess2.num_malade].valide = 1;
        Tcr[mess2.num_malade].num_organe = mess2.num_organe;
        printf("[DONNEUR]: Commande enregistree pour patient critique %d (organe: %d)\n", mess2.num_malade, mess2.num_organe);
    } else {
        Tncr[mess2.num_malade].valide = 1;
        Tncr[mess2.num_malade].num_organe = mess2.num_organe;
        printf("[DONNEUR]: Commande enregistree pour patient non-critique %d (organe: %d)\n", mess2.num_malade, mess2.num_organe);
    }  
}

void deposer(int shmid, int Tmalade, int Nmalade, int Norgane) {

    struct Tampon *tampon = (struct Tampon*) shmat(shmid, NULL, 0);
    if (tampon == (void*)-1) {
        perror("shmat deposer");
        return;
    }
    
    int tail = tampon->tail;
    
    tampon->organes[tail].type_malade = Tmalade;
    tampon->organes[tail].num_malade = Nmalade;
    tampon->organes[tail].num_organe = Norgane;
    
    tampon->tail = (tail + 1) % N;
    
    shmdt(tampon);
}

int trouve(Request *T, int Nmalade, int Norgane) {
    if (T[Nmalade].valide == 1 && T[Nmalade].num_organe == Norgane) {
        return 1; 
    }
    return 0;
}

int recuvoir(const char *fifo, struct imp_msg *mess2) {
    int fd = open(fifo, O_RDONLY);
    if (fd == -1) {
        perror("open fifo read");
        return -1;
    }
    
    struct tube_msg tm;
    ssize_t n = read(fd, &tm, sizeof(tm));
    close(fd);
    
    if (n != sizeof(tm)) {
        return -1;
    }
    
    mess2->type_malade = tm.type_malade;
    mess2->num_malade = tm.num_malade;
    mess2->num_organe = tm.num_organe;
    
    return 0; 
}

int main(){
    srand(time(NULL) ^ getpid());

    key_t k_sem = ftok(FTOK_PATH, 'D');
    key_t k_shm = ftok(FTOK_PATH, 'E');

    int semid = semget(k_sem, 2, 0666);
    int shmid = shmget(k_shm, sizeof(struct Tampon), 0666);

    if(semid==-1 || shmid==-1){
        perror("donneur ipc");
        exit(1);
    }

    int *shm = (int*)shmat(shmid, NULL, 0);
    if (shm != (void*)-1) {

        if (shm[2] == 0) {
            shm[0] = 0;  // head
            shm[1] = 0;  // tail
            shm[2] = 0;  // count
        }
        shmdt(shm);
    }
    const char *fifo = "/tmp/tube_tp2";
    mkfifo(fifo, 0666);
    printf("DONNEUR prÃªt - Attente des commandes via tube...\n");

    Request Tcr[M1+1];
    Request Tncr[M2+1];
    for(int i=1; i<=M1; i++) {
        Tcr[i].valide = 0;
        Tcr[i].num_organe = 0;
    }
    
    for(int i=1; i<=M2; i++) {
        Tncr[i].valide = 0;
        Tncr[i].num_organe = 0;
    }

    struct imp_msg mess2;
    int nb_rep = 0;
    int i = 0;
    
    while(nb_rep < M1+M2){
        if (i<M1+M2) {
             if(recuvoir(fifo, &mess2) == 0) {
                enregistrer(Tcr, Tncr, mess2);
                i++;
            }
        }

        int Tmalade=rand() % 2 + 1;
        int Nmalade , Norgane ;
        const char *organe_nom;

        switch (Tmalade) {
            case 1 : //critique
                Nmalade = rand() % M1 +1;
                Norgane = rand() % N1 +1;
        
                if(trouve(Tcr, Nmalade, Norgane)) {
                    P(semid, EMPTY_SEM);
                    
                    deposer(shmid, Tmalade, Nmalade, Norgane);
                    P(semid, MUTEX_SEM);
                    struct Tampon *tampon = (struct Tampon*)shmat(shmid, NULL, 0);
                    if(tampon != (void*)-1) {
                        tampon->count = tampon->count + 1;
                        shmdt(tampon);
                    }
                    V(semid, MUTEX_SEM);

                    nb_rep++;
                    Tcr[Nmalade].valide = 0 ;

                    printf("[DONNEUR]: Organe N:%d fourni pour malade critique %d\n", Norgane, Nmalade);
                }
                break;
            
            case 2 : //non critique
                Nmalade = (rand() % M2) + 1;
                Norgane = (rand() % N2) + 1;
                
                if(trouve(Tncr, Nmalade, Norgane)) {
                    P(semid, EMPTY_SEM);

                    deposer(shmid, Tmalade, Nmalade, Norgane);
                    P(semid, MUTEX_SEM);
                    struct Tampon *tampon = (struct Tampon*)shmat(shmid, NULL, 0);
                    if(tampon != (void*)-1) {
                        tampon->count = tampon->count + 1;
                        shmdt(tampon);
                    }
                    V(semid, MUTEX_SEM);

                    nb_rep++;
                    Tncr[Nmalade].valide = 0 ;

                    printf("[DONNEUR]: Organe N:%d fourni pour malade non critique %d\n", Norgane, Nmalade);
                }
                break;
        }
        usleep(100000); 
    }

    printf("[DONNEUR]: Toutes les commandes traitees (%d organes fournis)\n", nb_rep);
    unlink(fifo);
    return 0;
}